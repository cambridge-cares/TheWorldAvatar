package uk.ac.cam.cares.jps.agent.dashboard.json.panel.types;

import uk.ac.cam.cares.jps.agent.dashboard.utils.StringHelper;

import java.util.List;

/**
 * A Java representation of a JSON-like model that encapsulates and enforces information about template panel syntax
 * specific to Grafana dashboard. This is a super class that is intended to be implemented by the subclass, and only provide common syntax.
 *
 * @author qhouyee
 */
public abstract class TemplatePanel {
    private final String measure;
    private String title;
    private String description;
    private String unit = "null";
    private StringBuilder querySyntax = new StringBuilder();
    private final String databaseConnectionId;
    protected final TransformationOptions transformations;

    /**
     * A constructor that sets up common aspects of the panels.
     *
     * @param measure            The measure name for this variable.
     * @param itemGroup          The item group for this measure - asset type or rooms.
     * @param databaseId         The database connection ID generated by Grafana.
     * @param timeSeriesMetadata A list of assets and their metadata for the specified measure.
     */
    protected TemplatePanel(String measure, String itemGroup, String databaseId, List<String[]> timeSeriesMetadata) {
        this(measure, databaseId);
        // Create the query syntax from the parameters
        // Assumes that each measure of a specific item group belongs to only 1 table
        String tableName = timeSeriesMetadata.get(0)[2];
        this.querySyntax.append("SELECT time AS \\\"time\\\", ${")
                // Custom csv parameter must be lower case with no spacing ie: measurenameitemgroup
                .append(StringHelper.formatVariableName(measure)).append(StringHelper.formatVariableName(itemGroup)).append(":csv} ")
                .append("FROM \\\"").append(tableName).append("\\\" WHERE $__timeFilter(time)");
        this.transformations.addOrganizeTransformation(timeSeriesMetadata);
    }

    /**
     * A constructor that initialises the measure and database connection ID, but requires users to set the query and transformation options.
     *
     * @param measure    The measure name for this variable.
     * @param databaseId The database connection ID generated by Grafana.
     */
    protected TemplatePanel(String measure, String databaseId) {
        this.measure = measure;
        this.databaseConnectionId = databaseId;
        this.transformations = new TransformationOptions();
    }

    /**
     * Gets the measure of this panel.
     */
    public String getMeasure() {
        return this.measure;
    }

    public String getUnit() {
        return this.unit;
    }

    public void setUnit(String unit) {
        this.unit = unit;
    }

    /**
     * Sets the title.
     */
    protected void setTitle(String title) {
        this.title = title;
    }

    /**
     * Sets the description.
     */
    protected void setDescription(String description) {
        this.description = description;
    }

    /**
     * Sets the query syntax.
     */
    protected void setQuery(StringBuilder query) {
        this.querySyntax = query;
    }

    /**
     * Construct the common JSON parts for panel as a StringBuilder which will continue to append specific syntax for different query types.
     *
     * @return The variable syntax as a StringBuilder.
     */
    protected String genCommonJson(int height, int width, int xPosition, int yPosition) {
        verifyVariable(this.title, "Title");
        verifyVariable(this.description, "Description");
        return "\"id\": null," +  // Generate a new ID for this panel
                // Title of this panel
                "\"title\": \"" + this.title + "\"," +
                // Description for this panel
                "\"description\": \"" + this.description + "\"," +
                // Postgres datasource
                "\"datasource\": {\"type\": \"postgres\", \"uid\": \"" + this.databaseConnectionId + "\"}," +
                // Targets the written queries with their configuration to execute and retrieve data
                "\"targets\": [{\"datasource\":{\"type\":\"postgres\",\"uid\":\"" + this.databaseConnectionId + // Ensure data source is postgres
                // Query configurations
                "\"}, \"editorMode\":\"code\",\"format\":\"table\",\"rawQuery\":true,\"refId\":\"A\"," +
                "\"sql\":{\"columns\": [{\"parameters\": [],\"type\":\"function\"}], \"groupBy\": [{\"property\":{\"type\":\"string\"},\"type\":\"groupBy\"}],\"limit\":50}," +
                // Query to be executed
                "\"rawSql\":\"" + this.querySyntax + "\"}]," +
                // Grid position: Two panels of height:4 and width:6 will be found at (0,0), (6,4) coordinates
                // Height and width are dimensions of the panel
                "\"gridPos\":{\"h\":" + height + ",\"w\":" + width +
                // x and y are the placement position within the dashboard/grid
                ",\"x\":" + xPosition + ",\"y\":" + yPosition + "}," +
                "\"transformations\":" + this.transformations.construct();
    }

    /**
     * An abstract method to construct the variable syntax required. This method must be overridden to be executed in the implemented classes.
     */
    public abstract String construct(int height, int width, int xPosition, int yPosition);

    /**
     * Verifies if the mandatory variable exists.
     *
     * @throws NullPointerException when variable is empty.
     */
    private void verifyVariable(String variable, String varType) {
        if (variable == null) {
            throw new NullPointerException(varType + " has not yet been set or is empty!");
        }
    }
}
