# Standard library imports
import logging
import json, ast
import uuid

# Third party imports
from flask import Flask, request
from samgeo import tms_to_geotiff
from samgeo.text_sam import LangSAM

# Local application imports
from .utils.stack_configs import QUERY_ENDPOINT_STACK
from .utils.stack_configs import DB_QUERY_URL_STACK, DB_QUERY_USER_STACK, DB_QUERY_PASSWORD_STACK
# from .utils.upload_postgis import upload_to_postgis
from .utils.stackclients import GdalClient, GeoserverClient, OntopClient, PostGISClient, create_geojson_for_postgis
from .utils.jpsSingletons import stackClientsGw

from .algorithms.k_means import raster_to_clusters, raster_to_geojson

SAM = None

# Create the Flask app object
app = Flask(__name__)

@app.route('/SAM_setup', methods=['GET'])
def SAM_setup():
    modeltype = SAM_Setup_check_request_parameters(request.args)
    global SAM
    if SAM is not None:
        return 'The SAM model has already been initialized'
    SAM = LangSAM(model_type=modeltype)
    return 'The SAM model has been initialized'

@app.route('/k-means-cluster-segmentation', methods=['GET'])
def k_means_cluster_segmentation():
    if k_means_check_request_parameters(request.args) is not True:
        return k_means_check_request_parameters(request.args)
    n_clusters, input_file, tablename = request.args.get('n_clusters'), request.args.get('file'), request.args.get('tablename')
    value_to_object_dict = None
    try:
        #value_to_object_list = json.loads(request.args.get('value_to_object_list'))
        value_to_object_dict = ast.literal_eval(request.args.get('value_to_object_dict'))
        logging.error(value_to_object_dict)
    except:
        logging.error("The value_to_object_list parameter is not a valid JSON string. Please check the parameter.")

    # clusters.tif will be generated by running raster_to_clusters()
    averages, labels = raster_to_clusters(input_file=input_file, n_clusters=int(n_clusters))
    raster_to_geojson('clusters.tif', averages, 'segment.geojson', value_to_object_dict)
    upload_geojson("segment.geojson", tablename)
    return 'The k-means clustering segmentation has been completed. Please check GeoServer and PostGIS for the results.'

@app.route('/SAM-semantic-segmentation', methods=['GET'])
def SAM_semantic_segmentation():
    if SAM_check_request_parameters(request.args) is not True:
        return SAM_check_request_parameters(request.args)
    # Get the bbox from the request
    minLon, minLat, maxLon, maxLat, tablename =  request_arg.get('minLon'), request_arg.get('minLat'), request_arg.get('maxLon'), request_arg.get('maxLat'), request_arg.get('tablename')
    bbox = [minLon, minLat, maxLon, maxLat]
    #bbox = [103.771545,1.303388,103.777446,1.309137]  # NUS UTown

    # Get the model specifics from the request
    global SAM
    if SAM is None:
        logging.info('Initializing SAM model')
        SAM = LangSAM()

    tms_to_geotiff(output="Image.tif", bbox=bbox, zoom=19, source="Satellite", overwrite=True)

    text_prompt = "rooftops"

    SAM.predict("Image.tif", text_prompt, box_threshold=0.2, text_threshold=0.25)
    logging.info('predicted')
    SAM.show_anns(
        cmap='Greys_r',
        add_boxes=False,
        alpha=1,
        title='Automatic Segmentation of Houses',
        blend=False,
        output='segmented.tif',
    )

    SAM.raster_to_vector("segmented.tif", "segmented.geojson")
    upload_geojson("segmented.geojson", tablename)
    return 'The SAM semantic segmentation has been completed. Please check GeoServer and PostGIS for the results.'

@app.route('/update-obda', methods=['GET'])
def update_obda_mapping():
    logging.info('Uploading obda mapping to Ontop')
    OntopClient.upload_ontop_mapping('./GeoSegmentAgent/obda_mapping/segmentation.obda')
    return 'OBDA Mapping of combined data has been updated.'

def upload_geojson(filename, tablename):
    # Initialise relevant Stack Clients and parameters
    # postgis_client = PostGISClient(dburl=DB_QUERY_URL_STACK, dbuser=DB_QUERY_USER_STACK, dbpassword=DB_QUERY_PASSWORD_STACK, database="geosegment")
    gdal_client = GdalClient()
    geoserver_client = GeoserverClient()

    # Open the file and load it into a Python dictionary
    with open(filename, 'r') as f:
        data = json.load(f)

    # Convert the Python dictionary to a JSON-formatted string
    geojson_string = str(json.dumps(data))

    # Now geojson_string contains the GeoJSON data as a string
    gdal_client.uploadGeoJSON(geojson_string=geojson_string, database="postgres", table=tablename)

    geoserver_client.create_workspace(workspace="geosegment")
    geoserver_client.create_postgis_layer(geoserver_workspace="geosegment", geoserver_layer=tablename, postgis_database="postgres")


@app.route('/')
def default():
    msg = "The GeoSegmentAgent offers the segmentation of raster data via the specified API endpoints:<BR>"
    msg += "<BR>"
    msg += "Request to instantiate Segment Anything Model (SAM) from Meta:"
    msg += "/SAM_setup"
    msg += "<BR>"
    msg += "Request to segment raster data using SAM:"
    msg += "/SAM-semantic-segmentation"
    msg += "<BR>"
    msg += "Request to segment raster data using k-means clustering:"
    msg += "/k-means-cluster-segmentation"
    msg += "<BR>"
    msg += "<BR>"
    msg += "Please follow the instructions returned by the specific API endpoint you wish to run."
    msg += "<BR>"
    msg += "Upon a successful segmentation, the results will be uploaded to GeoServer and PostGIS for visualisation and downstream applications."
    return msg

def SAM_Setup_check_request_parameters(request_arg):
    msg = "To instantiate the SAM model, you need to specify the model type by providing a request parameter.<BR>"
    msg = "It can be one of the following: vit_h (2.4GB), vit_l (1.2GB), vit_b (358MB).<BR>"
    msg += "- ModelType <BR>"
    if request_arg is None:
        return msg
    if request_arg == '':
        return msg
    if 'ModelType' not in request_arg:
        return msg
    if request_arg['ModelType'] == '' or request_arg['ModelType'] not in ['vit_h', 'vit_l', 'vit_b']:
        return msg
    return request_arg.get('ModelType')


def SAM_check_request_parameters(request_arg):
    msg = "The SAM model in GeoSegment agent requires the following request parameters to be provided:<BR>"
    msg += "- minLon <BR>"
    msg += "- minLat <BR>"
    msg += "- maxLon <BR>"
    msg += "- maxLat <BR>"
    msg += "- tablename <BR>"

    if request_arg is None:
        return msg
    if request_arg == '':
        return msg
    if 'minLon' not in request_arg or 'minLat' not in request_arg or 'maxLon' not in request_arg or 'maxLat' not in request_arg:
        return msg
    if request_arg['minLon'] == '' or request_arg['minLat'] == '' or request_arg['maxLon'] == '' or request_arg['maxLat'] == '':
        return msg
    if float(request_arg['minLon']) > float(request_arg['maxLon']):
        return msg
    if float(request_arg['minLat']) > float(request_arg['maxLat']):
        return msg
    if 'tablename' not in request_arg:
        return msg
    return True

def k_means_check_request_parameters(request_arg):
    msg = "The k-means model in GeoSegment agent requires the following request parameters to be provided:<BR>"
    msg += "- n_clusters <BR>"
    msg += "- file (in raster format, under the 'raster_input' folder) <BR>"
    msg += "- tablename <BR>"
    msg += "- Key-value pair for raster bands E.g., [{10:\"tree\"}, {20:\"building\"}, {30:\"road\"}] (Optional) <BR>"
    if request_arg is None:
        return msg
    if request_arg == '':
        return msg
    if 'n_clusters' not in request_arg or 'file' not in request_arg or 'tablename' not in request_arg:
        return msg
    if request_arg['n_clusters'] == '' or request_arg['file'] == '' or request_arg['tablename'] == '':
        return msg
    return True