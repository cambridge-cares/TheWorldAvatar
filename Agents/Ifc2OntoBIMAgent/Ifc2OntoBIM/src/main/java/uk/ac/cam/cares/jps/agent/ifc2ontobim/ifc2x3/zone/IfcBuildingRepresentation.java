package uk.ac.cam.cares.jps.agent.ifc2ontobim.ifc2x3.zone;

import org.apache.jena.rdf.model.Statement;
import uk.ac.cam.cares.jps.agent.ifc2ontobim.ifcparser.OntoBimConstant;
import uk.ac.cam.cares.jps.agent.ifc2ontobim.utils.StatementHandler;
import uk.ac.cam.cares.jps.agent.ifc2ontobim.utils.StringUtils;

import java.util.LinkedHashSet;
import java.util.UUID;

/**
 * A class representing the IfcBuildingRepresentation concept in OntoBIM.
 *
 * @author qhouyee
 */
public class IfcBuildingRepresentation extends IfcAbstractRepresentation {
    private final String siteIRI;
    private final String botBuildingIRI;
    private final String addressIRI;
    private final String projectIRI;
    private final String unitIRI;
    private final Double refElevation;
    private final Double terrainElevation;
    private final String[] address;

    /**
     * Standard Constructor initialising the necessary and optional inputs.
     *
     * @param name         The name of this IFC object.
     * @param uid          The IFC uid generated for this object.
     * @param placementIri The local placement IRI for the zone's position.
     * @param projectIri   The project's IFC representation IRI if this building instance is the root zone.
     * @param siteIri      The IRI of bot:Site that is linked to this building instance.
     * @param refElevation An optional field containing the reference elevation values stored in IFC.
     * @param terElevation An optional field containing the terrain elevation values stored in IFC.
     * @param unitIri      An optional field for the elevation units.
     * @param address      An array containing the address, town, region, country, and postal code.
     */
    public IfcBuildingRepresentation(String name, String uid, String placementIri, String projectIri, String siteIri, String refElevation, String terElevation, String unitIri, String[] address) {
        // Initialise the super class
        super(OntoBimConstant.BUILDING_REP_CLASS, name, uid, placementIri);
        this.siteIRI = siteIri;
        // Generate a new bot Building IRI
        this.botBuildingIRI = this.getPrefix() + OntoBimConstant.BUILDING_CLASS + OntoBimConstant.UNDERSCORE + UUID.randomUUID();
        this.addressIRI = this.getPrefix() + OntoBimConstant.ADDRESS_CLASS + OntoBimConstant.UNDERSCORE + UUID.randomUUID();
        this.projectIRI = projectIri; // If the argument is null, the field will still be null
        this.address = address;
        if (refElevation != null) {
            // Remove the ` .` in elevation generated by IfcOwl (if any) to ensure double conversion is successful
            refElevation = refElevation.contains(" .") ? StringUtils.getStringBeforeLastCharacterOccurrence(refElevation, ".") : refElevation;
            this.refElevation = Double.valueOf(refElevation);
        } else {
            this.refElevation = null;
        }
        if (terElevation != null) {
            terElevation = terElevation.contains(" .") ? StringUtils.getStringBeforeLastCharacterOccurrence(terElevation, ".") : terElevation;
            this.terrainElevation = Double.valueOf(terElevation);
        } else {
            this.terrainElevation = null;
        }
        this.unitIRI = unitIri;
    }

    public String getBotBuildingIRI() {
        return botBuildingIRI;
    }

    protected Double getRefElevation() {
        return this.refElevation;
    }

    protected Double getTerElevation() {
        return this.terrainElevation;
    }

    /**
     * Generate and add the statements required for this Class to the statement set input.
     *
     * @param statementSet The set containing the new ontoBIM triples.
     */
    @Override
    public void constructStatements(LinkedHashSet<Statement> statementSet) {
        super.addIfcAbstractRepresentationStatements(statementSet, OntoBimConstant.BIM_BUILDING_REP_CLASS);
        StatementHandler.addStatement(statementSet, this.getBotBuildingIRI(), OntoBimConstant.RDF_TYPE, OntoBimConstant.BOT_BUILDING_CLASS);
        StatementHandler.addStatement(statementSet, this.getBotBuildingIRI(), OntoBimConstant.BIM_HAS_IFC_REPRESENTATION, this.getIri());
        StatementHandler.addStatement(statementSet, this.siteIRI, OntoBimConstant.BOT_HAS_BUILDING, this.getBotBuildingIRI());
        StatementHandler.addStatement(statementSet, this.getBotBuildingIRI(), OntoBimConstant.BUILT_ENV_HAS_ADDRESS, this.addressIRI);
        StatementHandler.addStatement(statementSet, this.addressIRI, OntoBimConstant.RDF_TYPE, OntoBimConstant.CONTACT_ADDRESS_CLASS);
        if (!this.address[0].isEmpty()) {
            // Due to the different street naming patterns in Singapore and Europe, the address is split using a series of regex delimiters
            // See test cases for the possible variations
            // The first split retrieves the street number, which is always last and on a whitespace followed by a digit.
            // Effectively, this splits a street for eg 52 Road Street 45 into "52 Road Street" and "45"
            String[] street = address[0].split("\\s+(?=\\d+$)");
            // If there is a second array item, this item will always be the street number
            if (street.length > 1)
                StatementHandler.addStatement(statementSet, this.addressIRI, OntoBimConstant.ICONTACT_HAS_STREET_NUMBER, street[1].trim(), false);
            // The second split retrieves the street name and separates the block number if it exists. For eg:
            // 9 Plain Street will give "9" and "Plain Street", while Blk 5 Leamer Road will give "Blk 5" and "Leamer Road".
            street = street[0].split("(?<=\\d\\w|\\d)+\\s", 2);
            // When there is only one result, it means that there is no block number and this will be the street name
            if (street.length == 1)
                StatementHandler.addStatement(statementSet, this.addressIRI, OntoBimConstant.ICONTACT_HAS_STREET, street[0].trim(), false);
            else {
                // For more than one result, block number is first, and street name is second
                StatementHandler.addStatement(statementSet, this.addressIRI, OntoBimConstant.BUILT_ENV_HAS_UNIT_NAME, street[0].trim(), false);
                StatementHandler.addStatement(statementSet, this.addressIRI, OntoBimConstant.ICONTACT_HAS_STREET, street[1].trim(), false);
            }

        }
        if (!this.address[1].isEmpty())
            StatementHandler.addStatement(statementSet, this.addressIRI, OntoBimConstant.ICONTACT_HAS_CITY, this.address[1], false);
        if (!this.address[2].isEmpty())
            StatementHandler.addStatement(statementSet, this.addressIRI, OntoBimConstant.ICONTACT_HAS_STATE, this.address[2], false);
        if (!this.address[3].isEmpty())
            StatementHandler.addStatement(statementSet, this.addressIRI, OntoBimConstant.ICONTACT_HAS_COUNTRY, this.address[3], false);
        if (!this.address[4].isEmpty())
            StatementHandler.addStatement(statementSet, this.addressIRI, OntoBimConstant.ICONTACT_HAS_POSTAL_CODE, this.address[4], false);
        if (this.projectIRI != null) {
            StatementHandler.addStatement(statementSet, this.projectIRI, OntoBimConstant.BIM_HAS_ROOT_ZONE, this.getIri());
        }
        // Add the statements for Reference Elevation if it exists
        if (this.refElevation != null) {
            String refElevHeightInst = this.getPrefix() + "Height_" + UUID.randomUUID();
            String refElevMeasureInst = this.getPrefix() + "Measure_" + UUID.randomUUID();
            StatementHandler.addStatement(statementSet, this.getIri(), OntoBimConstant.BIM_HAS_REF_ELEVATION, refElevHeightInst);
            StatementHandler.addStatement(statementSet, refElevHeightInst, OntoBimConstant.RDF_TYPE, OntoBimConstant.HEIGHT_CLASS);
            StatementHandler.addStatement(statementSet, refElevHeightInst, OntoBimConstant.OM_HAS_VALUE, refElevMeasureInst);
            StatementHandler.addStatement(statementSet, refElevMeasureInst, OntoBimConstant.RDF_TYPE, OntoBimConstant.MEASURE_CLASS);
            StatementHandler.addStatement(statementSet, refElevMeasureInst, OntoBimConstant.OM_HAS_NUMERICAL_VALUE, this.refElevation);
            StatementHandler.addStatement(statementSet, refElevMeasureInst, OntoBimConstant.OM_HAS_UNIT, this.unitIRI);
        }
        // Add the statements for Terrain Elevation if it exists
        if (this.terrainElevation != null) {
            String terElevHeightInst = this.getPrefix() + "Height_" + UUID.randomUUID();
            String terElevMeasureInst = this.getPrefix() + "Measure_" + UUID.randomUUID();
            StatementHandler.addStatement(statementSet, this.getIri(), OntoBimConstant.BIM_HAS_TER_ELEVATION, terElevHeightInst);
            StatementHandler.addStatement(statementSet, terElevHeightInst, OntoBimConstant.RDF_TYPE, OntoBimConstant.HEIGHT_CLASS);
            StatementHandler.addStatement(statementSet, terElevHeightInst, OntoBimConstant.OM_HAS_VALUE, terElevMeasureInst);
            StatementHandler.addStatement(statementSet, terElevMeasureInst, OntoBimConstant.RDF_TYPE, OntoBimConstant.MEASURE_CLASS);
            StatementHandler.addStatement(statementSet, terElevMeasureInst, OntoBimConstant.OM_HAS_NUMERICAL_VALUE, this.terrainElevation);
            StatementHandler.addStatement(statementSet, terElevMeasureInst, OntoBimConstant.OM_HAS_UNIT, this.unitIRI);
        }
    }
}
